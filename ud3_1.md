# UD3 - Automatización de tareas: Construcción de guiones de administración

- [1. Introducción: La Importancia de las Rutinas en la Automatización de Tareas](#1-introducción-la-importancia-de-las-rutinas-en-la-automatización-de-tareas)
  - [1.1. ¿Por qué utilizar rutinas?](#11-por-qué-utilizar-rutinas)
  - [1.2. Aplicación práctica para un DBA en la Automatización de Tareas](#12-aplicación-práctica-para-un-dba-en-la-automatización-de-tareas)
- [2. Rutinas: procedimientos y funciones](#2-rutinas-procedimientos-y-funciones)
  - [2.1. Creación de Procedimientos y Funciones](#21-creación-de-procedimientos-y-funciones)
  - [2.2. Parámetros de procedimientos y funciones](#22-parámetros-de-procedimientos-y-funciones)
  - [2.3. Sección de características](#23-sección-de-características)
  - [2.4. Cuerpo de las rutinas](#24-cuerpo-de-las-rutinas)
    - [2.4.1. Concepto de Variable y su Uso](#241-concepto-de-variable-y-su-uso)
    - [2.4.2. Alcance de las Variables](#242-alcance-de-las-variables)
    - [2.4.3. Estructuras de Control](#243-estructuras-de-control)
    - [2.4.4. ¿Cómo puedo definir las condiciones?](#244-cómo-puedo-definir-las-condiciones)
    - [2.4.5. Estructuras Repetitivas](#245-estructuras-repetitivas)
  - [2.5. Privilegios y Seguridad en Rutinas](#25-privilegios-y-seguridad-en-rutinas)
  - [2.6. Eliminación y Modificación de Rutinas](#26-eliminación-y-modificación-de-rutinas)
- [3. Eventos en mysql](#3-eventos-en-mysql)
  - [3.1. ¿Qué es un evento en MySQL?](#31-qué-es-un-evento-en-mysql)
  - [3.2. Planificador de eventos](#32-planificador-de-eventos)
    - [3.2.1. ¿Qué es el planificador de eventos?](#321-qué-es-el-planificador-de-eventos)
    - [3.2.2. Verificar el estado del planificador de eventos](#322-verificar-el-estado-del-planificador-de-eventos)
    - [3.2.3. Habilitar o deshabilitar el planificador de eventos](#323-habilitar-o-deshabilitar-el-planificador-de-eventos)
    - [3.2.4. Consideraciones sobre el planificador de eventos](#324-consideraciones-sobre-el-planificador-de-eventos)
  - [3.3. Creación de Eventos](#33-creación-de-eventos)
    - [3.3.1. Sintaxis básica para crear eventos](#331-sintaxis-básica-para-crear-eventos)
    - [3.3.2. Tipos de programación](#332-tipos-de-programación)
    - [3.3.3. Opciones adicionales en la creación de eventos](#333-opciones-adicionales-en-la-creación-de-eventos)
    - [3.3.4. Verificar eventos creados](#334-verificar-eventos-creados)
    - [3.3.5. Ejemplo práctico](#335-ejemplo-práctico)
  - [3.4. Modificación de Eventos](#34-modificación-de-eventos)
    - [3.4.1. Sintaxis básica de ALTER EVENT](#341-sintaxis-básica-de-alter-event)
    - [3.4.2. Opciones disponibles para modificar un evento](#342-opciones-disponibles-para-modificar-un-evento)
    - [3.4.3. Ejemplo completo: Modificar un evento](#343-ejemplo-completo-modificar-un-evento)
  - [3.5. Eliminación de Eventos](#35-eliminación-de-eventos)
    - [3.5.1. Sintaxis básica de `DROP EVENT`](#351-sintaxis-básica-de-drop-event)
    - [3.5.2. Ejemplo básico](#352-ejemplo-básico)
    - [3.5.3. Consideraciones importantes al eliminar eventos](#353-consideraciones-importantes-al-eliminar-eventos)
  - [3.6. Privilegios Relacionados con Eventos](#36-privilegios-relacionados-con-eventos)
    - [3.6.1. Privilegios necesarios](#361-privilegios-necesarios)
    - [3.6.2. Verificar privilegios de un usuario](#362-verificar-privilegios-de-un-usuario)
    - [3.6.3. Restricciones de seguridad](#363-restricciones-de-seguridad)
  - [3.7. Consideraciones de Seguridad y Rendimiento en Eventos](#37-consideraciones-de-seguridad-y-rendimiento-en-eventos)
    - [3.7.1. Consideraciones de Seguridad](#371-consideraciones-de-seguridad)
    - [3.7.2. Consideraciones de Rendimiento](#372-consideraciones-de-rendimiento)
  - [3.8. Ejemplos Prácticos de Uso de Eventos](#38-ejemplos-prácticos-de-uso-de-eventos)
    - [3.8.1. Limpieza Automática de Registros Antiguos](#381-limpieza-automática-de-registros-antiguos)
    - [3.8.2. Generación de Informes Periódicos](#382-generación-de-informes-periódicos)
    - [3.8.3. Reseteo Automático de una Tabla Temporal](#383-reseteo-automático-de-una-tabla-temporal)
    - [3.8.4. Deshabilitación Temporal de Eventos](#384-deshabilitación-temporal-de-eventos)
- [4. Introducción a los Disparadores](#4-introducción-a-los-disparadores)
  - [4.1. ¿Qué son los disparadores?](#41-qué-son-los-disparadores)
  - [4.2. Creación de Disparadores](#42-creación-de-disparadores)
    - [4.2.1. Consideraciones al crear disparadores](#421-consideraciones-al-crear-disparadores)
    - [4.2.2. Errores comunes al crear disparadores](#422-errores-comunes-al-crear-disparadores)
  - [4.3. Modificación, eliminación y muestra de disparadores](#43-modificación-eliminación-y-muestra-de-disparadores)
- [5. Gestión de Errores y Condiciones (Handlers)](#5-gestión-de-errores-y-condiciones-handlers)
  - [5.1. Introducción a la Gestión de Errores](#51-introducción-a-la-gestión-de-errores)
    - [5.1.1. Qué son las condiciones y los handlers](#511-qué-son-las-condiciones-y-los-handlers)
    - [5.1.2. Importancia del manejo de errores en bases de datos](#512-importancia-del-manejo-de-errores-en-bases-de-datos)
    - [5.1.3. Diferencia entre errores y advertencias en MySQL](#513-diferencia-entre-errores-y-advertencias-en-mysql)
  - [5.2. Declaración y Sintaxis](#52-declaración-y-sintaxis)
    - [5.2.1. Estructura básica DECLARE ... HANDLER](#521-estructura-básica-declare--handler)
    - [5.2.2. Ámbito de los handlers y reglas de declaración](#522-ámbito-de-los-handlers-y-reglas-de-declaración)
  - [5.3. Tipos de Condiciones](#53-tipos-de-condiciones)
    - [5.3.1. SQLEXCEPTION](#531-sqlexception)
    - [5.3.2. SQLWARNING](#532-sqlwarning)
    - [5.3.3. NOT FOUND](#533-not-found)
    - [5.3.4. Códigos de error específicos de MySQL](#534-códigos-de-error-específicos-de-mysql)
    - [5.3.5. Condiciones personalizadas (CONDITION)](#535-condiciones-personalizadas-condition)
  - [5.4. Manejo de Errores en la Práctica](#54-manejo-de-errores-en-la-práctica)
    - [5.4.1. Handlers en Procedimientos Almacenados](#541-handlers-en-procedimientos-almacenados)
    - [5.4.2. Handlers en Triggers](#542-handlers-en-triggers)
    - [5.4.3. Handlers en Bloques BEGIN-END](#543-handlers-en-bloques-begin-end)
    - [5.4.4. Handlers con Cursores](#544-handlers-con-cursores)
  - [5.5. Buenas Prácticas](#55-buenas-prácticas)
    - [5.5.1. Estrategias de Gestión de Errores](#551-estrategias-de-gestión-de-errores)
    - [5.5.2. Logging de Errores](#552-logging-de-errores)
    - [5.5.3. Depuración y Troubleshooting](#553-depuración-y-troubleshooting)
    - [5.5.4. Casos Comunes y Soluciones Recomendadas](#554-casos-comunes-y-soluciones-recomendadas)
  - [5.6. Ejemplos Prácticos](#56-ejemplos-prácticos)
    - [5.6.1. Manejo Básico de Errores](#561-manejo-básico-de-errores)
    - [5.6.2. Gestión de Errores en Transacciones](#562-gestión-de-errores-en-transacciones)
    - [5.6.3. Logging de Errores en Tabla](#563-logging-de-errores-en-tabla)
    - [5.6.4. Handlers Múltiples](#564-handlers-múltiples)
- [6. Introducción a los Cursores](#6-introducción-a-los-cursores)
  - [6.1. ¿Qué son los cursores?](#61-qué-son-los-cursores)
  - [6.2. ¿Cuándo y por qué usarlos?](#62-cuándo-y-por-qué-usarlos)
  - [6.3. Tipos de Cursores](#63-tipos-de-cursores)
    - [6.3.1. Cursores implícitos](#631-cursores-implícitos)
    - [6.3.2. Cursores Explícitos](#632-cursores-explícitos)
  - [6.4. Creación y Uso de Cursores](#64-creación-y-uso-de-cursores)
    - [6.4.1. Puntos Importantes a Recordar](#641-puntos-importantes-a-recordar)
  - [6.5. Características principales de los cursores explícitos en MySQL](#65-características-principales-de-los-cursores-explícitos-en-mysql)
    - [6.5.1. Son unidireccionales (forward-only)](#651-son-unidireccionales-forward-only)
    - [6.5.2. Son de solo lectura (read-only)](#652-son-de-solo-lectura-read-only)
    - [6.5.3. No son actualizables](#653-no-son-actualizables)
    - [6.5.4. No son scrollables (no permiten movimientos hacia atrás o saltos)](#654-no-son-scrollables-no-permiten-movimientos-hacia-atrás-o-saltos)
  - [6.6. Ejemplos Prácticos](#66-ejemplos-prácticos)
  - [6.7. Limitaciones de los Cursores](#67-limitaciones-de-los-cursores)
  - [6.8. Buenas Prácticas con Cursores](#68-buenas-prácticas-con-cursores)
- [7. Documentación](#7-documentación)

## 1. Introducción: La Importancia de las Rutinas en la Automatización de Tareas

En la administración de bases de datos, las rutinas (**procedimientos almacenados y funciones**) son herramientas fundamentales para garantizar la eficiencia, la repetibilidad y la seguridad en la ejecución de tareas repetitivas o complejas. Su uso permite **encapsular la lógica del negocio** directamente en el servidor de bases de datos, reduciendo la necesidad de depender de aplicaciones externas para manejar operaciones críticas.

Las **rutinas**, junto a los **disparadores** o **triggers** y a los **eventos**, son particularmente útiles en entornos donde la consistencia y el rendimiento son esenciales, ya que se ejecutan directamente en el servidor, evitando la sobrecarga de la red al minimizar el intercambio de datos entre el cliente y el servidor. Además, proporcionan una manera de **centralizar las operaciones frecuentes**, asegurando que todos los usuarios y aplicaciones sigan el mismo flujo lógico al interactuar con los datos.

### 1.1. ¿Por qué utilizar rutinas?

1. **Eficiencia**:

   1. Las rutinas permiten procesar operaciones complejas en el lado del servidor, reduciendo los tiempos de espera y optimizando los recursos del sistema.

   2. Al agrupar múltiples comandos SQL en una rutina, se evita enviar comandos individuales desde la aplicación al servidor, mejorando el rendimiento.

2. **Consistencia**:

   1. La lógica encapsulada en procedimientos o funciones garantiza que las reglas del negocio se implementen de manera uniforme en todas las operaciones.

   2. Las rutinas también facilitan la validación de datos y la implementación de controles para evitar errores.

3. **Automatización**:

   1. Permiten automatizar tareas recurrentes, como actualizaciones masivas, generación de reportes, limpieza de datos antiguos o cálculo de métricas.

   2. Cuando se combinan con eventos programados, las rutinas son una herramienta poderosa para la planificación de tareas sin intervención manual.

4. **Mantenimiento centralizado**:

   1. Los cambios en la lógica se pueden realizar directamente en el servidor, sin necesidad de modificar múltiples aplicaciones o scripts que interactúen con la base de datos.

### 1.2. Aplicación práctica para un DBA en la Automatización de Tareas

Un **Administrador de Bases de Datos (DBA)** utiliza las rutinas principalmente para automatizar y simplificar la administración diaria del sistema. Algunas aplicaciones comunes incluyen:

1. **Limpieza y Mantenimiento de Datos**

    **Ejemplo**: Creación de un procedimiento para eliminar registros obsoletos:

    ```sql
    CREATE PROCEDURE limpiar_registros()
    BEGIN
        DELETE FROM logs WHERE fecha < DATE_SUB(CURDATE(), INTERVAL 90 DAY);
    END;
    ```

    Un DBA podría combinar este procedimiento con un evento para ejecutarlo automáticamente cada semana:

    ```sql
    CREATE EVENT limpiar_logs
    ON SCHEDULE EVERY 7 DAY
    DO CALL limpiar_registros();
    ```

2. **Gestión de Reportes Periódicos**

    Los procedimientos pueden generar informes directamente desde la base de datos. Por ejemplo:

    ```sql
    CREATE PROCEDURE generar_reporte_ventas(fecha_inicio DATE, fecha_fin DATE)
    BEGIN
        SELECT producto, SUM(cantidad) AS total_vendido
        FROM ventas
        WHERE fecha BETWEEN fecha_inicio AND fecha_fin
        GROUP BY producto;
    END;
    ```

3. **Validación y Transformación de Datos**

    Las funciones permiten aplicar reglas de validación en tiempo real. Por ejemplo:

    ```sql
    CREATE FUNCTION validar_email(email VARCHAR(255)) RETURNS BOOLEAN
    BEGIN
        RETURN email LIKE '%_@_%._%';
    END;
    ```

4. **Automatización de Copias de Seguridad**

    Aunque las copias de seguridad suelen gestionarse fuera de MySQL, un DBA podría programar un procedimiento para volcar datos importantes en una tabla temporal antes de una operación crítica.

## 2. Rutinas: procedimientos y funciones

Las rutinas son un conjunto **de comandos SQL almacenados en el servidor**. De esta forma, un usuario puede ejecutar ese conjunto de comandos de una sola vez en lugar de tener que ejecutarlos de manera independiente.

¿Qué diferencia a los **procedimientos** y a las **funciones**?

- Las funciones devuelven un solo valor, mientras que los procedimientos pueden devolver varios o ninguno.

- Las sentencias `SELECT` que se emplean dentro de una función no son mostradas al terminar la ejecución de la misma; mientras que en los procedimientos sí se muestran, salvo las del tipo `SELECT...INTO` qué almacenan la salida en variables.

- La forma de invocarlos: mientras que la función se llama mediante: `SELECT nombre_func`, el procedimiento se llama utilizando `CALL nombre_proc`. Hay que recordar que phpMyAdmin no admite el uso de la sentencia `CALL`, lo que impide ejecutar procedimientos.

- A diferencia de los procedimientos almacenados, las funciones almacenadas se pueden utilizar en expresiones y pueden incluirse en otras funciones o procedimientos, así como en el interior de sentencias SQL como `SELECT`, `UPDATE`, `DELETE` e `INSERT`.

### 2.1. Creación de Procedimientos y Funciones

La sintaxis completa para la creación de un procedimiento o una función es la siguiente:

```sql
CREATE
    [DEFINER = user]
    PROCEDURE [IF NOT EXISTS] sp_name ([proc_parameter[,...]])
    [characteristic ...] routine_body

CREATE
    [DEFINER = user]
    FUNCTION [IF NOT EXISTS] sp_name ([func_parameter[,...]])
    RETURNS type
    [characteristic ...] routine_body

proc_parameter:
    [ IN | OUT | INOUT ] param_name type

func_parameter:
    param_name type

type:
    Any valid MySQL data type

characteristic: {
    COMMENT 'string'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
}

routine_body:
    SQL routine
```

En su sintaxis más básica, este sería un **ejemplo de procedimiento**:

```sql
DELIMITER //
CREATE PROCEDURE nombre_procedimiento(param1 Tipo, param2 Tipo)
BEGIN
    -- Bloque de instrucciones
END //
DELIMITER ;
```

Como vemos, el procedimiento comienza a definirse mediante `CREATE PROCEDURE`. A continuación, vemos que el procedimiento recibe un **nombre** (descriptivo, que indica qué realiza) y, posteriormente, encerrado entre paréntesis, una lista de **parámetros**, que son datos proporcionados al procedimiento para realizar su cometido.

Luego nos encontramos con la palabra reservada `BEGIN`, que indicaría el inicio del bloque de instrucciones que incluye nuestro procedimiento, y, tras estas, la palabra `END`, seguida del delimitador que hayamos configurado antes de crear el procedimiento.

*Nota: **Por qué usar `DELIMITER` en procedimientos almacenados***

*Por defecto, MySQL utiliza ‘`;`’ como delimitador para identificar el final de una instrucción SQL. Sin embargo, cuando estás creando un procedimiento o función, el cuerpo del procedimiento puede contener múltiples instrucciones SQL, y MySQL necesita saber que todas esas instrucciones forman parte de la definición del procedimiento, no comandos independientes.*

*Para resolver esto, se utiliza el comando `DELIMITER` para **cambiar temporalmente el delimitador** a algo distinto, como `//` o cualquier otra secuencia que no sea conflictiva, mientras se define el procedimiento. Al final de todo, se reestablece el delimitador al ‘`;`’.*

Ejemplo básico: Procedimiento para insertar un estudiante en la tabla `estudiantes`:

```sql
CREATE PROCEDURE insertar_estudiante(
    IN nombreEstudiante VARCHAR(100),
    IN correoEstudiante VARCHAR(100),
    IN fecha DATE
)
BEGIN
    INSERT INTO estudiantes (nombre, correo, fecha_matricula)
    VALUES (nombreEstudiante, correoEstudiante, fecha);
END;
```

El ejemplo anterior es simplemente demostrativo, ya que no tiene sentido crear un procedimiento para realizar una inserción, al menos que hagamos otras operaciones (por ejemplo, validación de datos o transformaciones previas). El procedimiento lleva por nombre insertar\_estudiante y tiene 3 parámetros (todos de tipo IN, es decir, de entrada, de los cuales podremos leer información, pero no escribir en ella). El primero tiene como nombre nombreEstudiante y es de tipo VARCHAR(100); el segundo tiene como nombre correoEstudiante  y es de tipo VARCHAR(100); y el tercero lleva por nombre fecha y es de tipo DATE. A ellos haremos referencia dentro del bloque **BEGIN ... EN**, como vemos, en una sentencia **INSERT**.

Por su parte, en su sintaxis más básica, este sería un **ejemplo de función:**

```sql
DELIMITER //
CREATE FUNCTION nombre_funcion(param Tipo) RETURNS Tipo
BEGIN
    -- Bloque de instrucciones
    RETURN valor;
END //

DELIMITER ;
```

### 2.2. Parámetros de procedimientos y funciones

Los **parámetros** permiten al procedimiento recibir y/o devolver información. Y pueden ser:

- De entrada: **`IN`**  
- De salida: **`OUT`**  
- De entrada/salida: **`INOUT`**

Para definir cada **parámetro** se sigue el siguiente formato:

```sql
[IN | OUT | INOUT] NombreParámetro Tipo
```

- **`IN`**: el procedimiento recibe el parámetro y no lo modifica. Lo usa para consultar y utilizar su valor.  
- **`OUT`**: el procedimiento únicamente puede escribir en el parámetro, no puede consultarlo.  
- **`INOUT`**: el procedimiento recibe el parámetro y puede consultarlo y modificarlo.

Los parámetros **`OUT`** o **`INOUT`** se usan cuando se desea que un procedimiento nos devuelva valores en determinadas variables, esto es, los parámetros de salida permiten simular que el procedimiento devuelve valores.

- Es obligatorio escribir una lista de parámetros, aunque sea una lista vacía, reflejada con **`( )`**.  
- Por defecto cada parámetro es de tipo **`IN`**. Si queremos especificar otro tipo se escribe delante del nombre del parámetro.

**`NombreParámetro:`** es el nombre que tendrá el parámetro y con el que nos referiremos a él en el cuerpo de la rutina.

**`Tipo`**: es el Tipo de datos devuelto, puede ser cualquier tipo de datos válido de MySQL(**`INT, DATE, CHAR, VARCHAR`**, etc).

**Ejemplo de procedimiento con validación de Usuario:**

Este procedimiento valida si un usuario existe y actualiza su último acceso. Usa:

- **`IN`**: Recibe el nombre del usuario.  
- **`OUT`**: Devuelve un mensaje indicando si el usuario existe o no.  
- **`INOUT`**: Actualiza la última fecha de acceso.

```sql
DELIMITER //
CREATE PROCEDURE validar_usuario(
    IN nombre_usuario VARCHAR(100),
    OUT mensaje VARCHAR(255),
    INOUT ultima_visita DATETIME
)
BEGIN
    -- Verificar si el usuario existe
    IF EXISTS (SELECT 1 FROM usuarios WHERE nombre = nombre_usuario) THEN
        -- Usuario encontrado, actualizar última visita
        UPDATE usuarios
        SET ultima_acceso = ultima_visita
        WHERE nombre = nombre_usuario;

        SET mensaje = 'Usuario encontrado y actualizado.';
    ELSE
        -- Usuario no encontrado
        SET mensaje = 'Usuario no encontrado.';
        SET ultima_visita = NULL;
    END IF;
END //

DELIMITER ;
```

**Uso del procedimiento:**

```sql
-- Definir una variable para la última visita y el mensaje
SET @ultima_visita = NOW();
SET @mensaje = '';

-- Llamar al procedimiento
CALL validar_usuario('Juan Pérez', @mensaje, @ultima_visita);

-- Ver los resultados
SELECT @mensaje AS Mensaje, @ultima_visita AS UltimaVisita;
```

**Salida esperada (usuario encontrado):**

```plaintext
Mensaje                     | UltimaVisita
----------------------------|------------------------
Usuario encontrado y actualizado. | 2024-12-20 12:34:56
```

**Salida esperada (usuario no encontrado)**:

```plaintext
Mensaje                     | UltimaVisita
----------------------------|------------------------
Usuario no encontrado.       | NULL
```

### 2.3. Sección de características

En la **sección de características** se puede especificar la siguiente información:

```sql
characteristic: {
    COMMENT 'string'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
}
```

- **`LANGUAGE SQL`** significa que el cuerpo del procedimiento está escrito en SQL. Por defecto se tiene esa característica para prever la posible construcción de procedimientos almacenados con otros lenguajes, como Java.  
- **`DETERMINISTIC / NOT DETERMINISTIC.`** El procedimiento se considera “determinista” si siempre produce el mismo resultado para los mismos parámetros de entrada, y “no determinista” si no es así. Por defecto es **`NOT DETERMINISTIC`**.  
- **`SQL SECURITY`** sirve especificar si el procedimiento es llamado, usando los permisos del usuario que lo creó (**`DEFINER`**, que es el valor por defecto), o usando los permisos del usuario que está haciendo la llamada (**`INVOKER`**).  
- **`COMMENT`** se usa para escribir el comentario que aparecerá cuando se ejecute una sentencia para ver el contenido de un procedimiento o de una función con:

**`SHOW CREATE PROCEDURE` o `SHOW CREATE FUNCTION`**

Las cláusulas de la sección de características tienen como **valores predeterminados** los siguientes:

- **`LANGUAGE SQL`**  
- **`NOT DETERMINISTIC`**
- **`SQL SECURITY DEFINER`**
- **`COMMENT ''`**

### 2.4. Cuerpo de las rutinas

Entendemos por el cuerpo de la rutina al conjunto de sentencias y operaciones realizadas entre las palabras `BEGIN` y `END` de un procedimiento o función.

Además de sentencias SQL, podremos utilizar otras estructuras como **bucles** y **condiciones**. Además, podemos utilizar **variables** y otras estructuras de SQL, como los **cursores**. Con todas estas herramientas, podremos programar el comportamiento de dicha rutina para que realice la tarea de nuestro interés.

#### 2.4.1. Concepto de Variable y su Uso

Una variable es un espacio en memoria que se utiliza para almacenar temporalmente valores que se usarán dentro del procedimiento o función.

En MySQL, las variables locales deben declararse dentro de un bloque `BEGIN...END` usando el comando `DECLARE`.

```sql
DECLARE nombre_variable TIPO [DEFAULT valor];
```

**Ejemplo:**

```sql
DECLARE contador INT DEFAULT 0;
DECLARE mensaje VARCHAR(100) DEFAULT 'Inicio del proceso';
```

Los tipos de variables pueden ser `INT`, `DECIMAL`, `CHAR`, `VARCHAR`, `DATE`, etc. Las variables pueden tomar valores calculados mediante `SET` o directamente en una consulta SQL con `SELECT INTO`.

**Ejemplo con `SET`:**

```sql
SET contador = contador + 1;
SET mensaje = 'Proceso completado';
```

Las expresiones anteriores debemos interpretarlas de derecha a izquierda, y teniendo en cuenta que `=` es el operador de asignacion, que permite asignar (dar un valor) a una variable. No debemos verlo como un operador que comprueba si dos cosas son iguales. Concretamente, las lineas anteriores debemos leerlas como: "*calculo 'contador + 1' y el resultado se lo asigno a la variable contador*", o "*asigno a la variable mensaje el valor 'Proceso completado'* ".

**Ejemplo con `SELECT INTO`:**

```sql
SELECT COUNT(*) INTO contador FROM estudiantes WHERE fecha_matricula > '2023-01-01';
```

#### 2.4.2. Alcance de las Variables

El **alcance de una variable** se refiere al contexto dentro del cual una variable es accesible y válida. En MySQL, el alcance de una variable local está limitado al bloque en el que fue declarada (dentro de un procedimiento, función o evento). Una vez que se sale de ese bloque, la variable deja de existir.

**Características del Alcance:**

- Las variables declaradas con `DECLARE` solo existen dentro del cuerpo del procedimiento o función donde se definen.  
- Al salir del bloque `BEGIN...END`, las variables locales se eliminan automáticamente.

**Ejemplo de Variable con Alcance Local:**

```sql
DELIMITER //
CREATE PROCEDURE ejemplo_alcance()
BEGIN
    DECLARE contador INT DEFAULT 0; -- Variable local
    SET contador = contador + 1;    -- Operación permitida dentro del bloque
    SELECT contador;                -- Visible dentro del procedimiento
END //
DELIMITER ;

CALL ejemplo_alcance(); -- Salida: 1
```

#### 2.4.3. Estructuras de Control

Las estructuras de control permiten tomar decisiones dentro de un procedimiento o función. MySQL admite estructuras condicionales como `IF`, `CASE`, y bloques de control de flujo.

**IF-THEN-ELSE:** Se usa para ejecutar diferentes bloques de código dependiendo de una **condición**.

**Sintaxis:**

```sql
IF condición THEN
    -- Bloque de código
ELSEIF otra_condición THEN
    -- Otro bloque de código
ELSE
    -- Código alternativo
END IF;
```

**Ejemplo:**

```sql
IF contador > 10 THEN
    SET mensaje = 'Contador alto';
ELSE
    SET mensaje = 'Contador bajo';
END IF;
```

**CASE:** Alternativa compacta a `IF-THEN-ELSE`.

**Sintaxis:**

```sql
CASE
    WHEN condición1 THEN resultado1
    WHEN condición2 THEN resultado2
    ELSE resultado_defecto
END;
```

**Ejemplo:**

```sql
SET mensaje = CASE
    WHEN contador > 10 THEN 'Contador alto'
    WHEN contador = 10 THEN 'Contador exacto'
    ELSE 'Contador bajo'
END;
```

#### 2.4.4. ¿Cómo puedo definir las condiciones?

Las condiciones en MySQL se construyen utilizando expresiones lógicas que se evalúan como verdaderas o falsas. Estas expresiones pueden incluir:

- Comparaciones entre valores.
- Llamadas a funciones.
- Operadores lógicos.
Ejemplos de condiciones válidas:

```sql
IF cantidad > 10 THEN -- Comparación directa
    ...
END IF;

WHILE EXISTS (SELECT 1 FROM tabla WHERE estado = 'pendiente') DO -- Función EXISTS
    ...
END WHILE;

CASE
    WHEN stock < 0 THEN 'Sin stock' -- Evaluación condicional
    ELSE 'Stock disponible'
END;

```

Estas condiciones se podrán aplicar tanto en las estructuras de control como en las estructuras de repetición, condicionando la ejecución de los bucles.

**Operadores para Condiciones:**

- Operadores de Comparación: se utilizan para comparar valores numéricos, cadenas o fechas.

  | Operador | Descripción | Ejemplo |
  | ----- | ----- | ----- |
  | `=` | Igual a | `precio = 100` |
  | `!=` | Diferente | `cantidad != 5` |
  | `<` | Menor que | `edad < 18` |
  | `>` | Mayor que | `ventas > 1000` |
  | `<=` | Menor o igual que | `fecha <= '2024-01-01'` |
  | `>=` | Mayor o igual que | `calificacion >= 6` |
  | `<=>` | Igual, considerando `NULL` | `valor <=> NULL` |

- Operadores Lógicos. permiten combinar varias condiciones en una expresión.

  | `AND` | Verdadero si ambas lo son | `cantidad > 0 AND stock > 0` |
  | :---- | :---- | :---- |
  | `OR` | Verdadero si una lo es | `precio < 50 OR descuento > 0` |
  | `NOT` | Niega la condición | `NOT (cantidad > 10)` |
  | `XOR` | Verdadero si una, pero no ambas | `ventas > 100 XOR devoluciones > 5` |

- Operadores de Comparación Avanzada:
  - BETWEEN ... AND: Verifica si un valor está en un rango.

    ```sql
    IF fecha BETWEEN '2024-01-01' AND '2024-12-31' THEN ...
    ```

  - IN: Comprueba si un valor pertenece a un conjunto.

    ```sql
    IF estado IN ('pendiente', 'completado') THEN ...
    ```

  - LIKE y NOT LIKE: Comparación con patrones.

    ```sql
    IF nombre LIKE 'A%' THEN ... -- Empieza con 'A'
    ```

  - IS NULL y IS NOT NULL: Verifica valores nulos.

    ```sql
    IF direccion IS NULL THEN
    ```

#### 2.4.5. Estructuras Repetitivas

Las estructuras repetitivas se usan para ejecutar un bloque de código varias veces. MySQL admite tres tipos principales: `WHILE`, `LOOP` y `REPEAT`.

**WHILE:** Ejecuta un bloque de código mientras la condición sea verdadera.

**Sintaxis:**

```sql
WHILE condición DO
    -- Código a ejecutar
END WHILE;
```

**Ejemplo:**

```sql
DECLARE contador INT DEFAULT 1;
WHILE contador <= 5 DO
    INSERT INTO log_proceso (mensaje) VALUES (CONCAT('Iteración ', contador));
    SET contador = contador + 1;
END WHILE;
```

**LOOP:** Ejecuta un bloque de código indefinidamente hasta que se use una condición de salida (`LEAVE`).

**Sintaxis:**

```sql
[nombrebucle:] LOOP
    -- Código a ejecutar
    IF condición_salida THEN
        LEAVE nombrebucle;
    END IF;
END LOOP nombrebucle;
```

**Ejemplo:**

```sql
DECLARE contador INT DEFAULT 1;
nombre_bucle: LOOP
    INSERT INTO log_proceso (mensaje) VALUES (CONCAT('Iteración ', contador));
    SET contador = contador + 1;
    IF contador > 5 THEN
        LEAVE nombre_bucle;
    END IF;
END LOOP nombre_bucle;
```

**REPEAT:** Ejecuta el bloque de código **al menos una vez** y luego verifica la condición al final.

**Sintaxis:**

```sql
REPEAT
    -- Código a ejecutar
UNTIL condición
END REPEAT;
```

**Ejemplo:**

```sql
DECLARE contador INT DEFAULT 1;

REPEAT
    INSERT INTO log_proceso (mensaje) VALUES (CONCAT('Iteración ', contador));
    SET contador = contador + 1;
UNTIL contador > 5
END REPEAT;
```

A continuación se presenta un procedimiento que utiliza variables, estructuras de control y repetitivas para procesar datos en la tabla `ventas` y calcular totales:

```sql
DELIMITER //

CREATE PROCEDURE procesar_ventas()
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE contador INT DEFAULT 0;

    -- Contar el total de registros
    SELECT COUNT(*) INTO total FROM ventas;

    -- Procesar cada registro
    nombre_bucle: WHILE contador < total DO
        SET contador = contador + 1;
        INSERT INTO log_proceso (mensaje) VALUES (CONCAT('Procesando registro ', contador));
    END WHILE;

    -- Mensaje final
    INSERT INTO log_proceso (mensaje) VALUES ('Proceso completado');
END //

DELIMITER ;
```

### 2.5. Privilegios y Seguridad en Rutinas

Para crear, modificar o ejecutar rutinas, los usuarios necesitan ciertos privilegios específicos:

- Privilegios para procedimientos y funciones:  
  - `CREATE ROUTINE`: Permite crear rutinas.  
  - `ALTER ROUTINE`: Permite modificar rutinas existentes.  
  - `EXECUTE`: Permite ejecutar rutinas creadas por otros.  
  - `DROP`: Permite eliminar rutinas.

Ejemplo de asignación de privilegios:

```sql
GRANT CREATE ROUTINE, EXECUTE ON universidad.* TO 'usuario'@'localhost';
```

### 2.6. Eliminación y Modificación de Rutinas

Para eliminar un procedimiento debemos utilizar la sentencia DROP:

```sql
DROP PROCEDURE IF EXISTS nombre_procedimiento;
DROP FUNCTION IF EXISTS nombre_funcion;
```

MySQL no permite modificar una rutina directamente, por lo que, si queremos hacer cambios en ella. debe eliminarse y volverse a crear.

## 3. Eventos en mysql

### 3.1. ¿Qué es un evento en MySQL?

Un evento en MySQL es una tarea programada que se ejecuta automáticamente en el servidor según una programación definida. Puede ser:

- **De ejecución única**: Se ejecuta solo una vez en un momento específico.  
- **Recurrente**: Se ejecuta de manera periódica en intervalos definidos.

### 3.2. Planificador de eventos

#### 3.2.1. ¿Qué es el planificador de eventos?

El planificador de eventos (`event_scheduler`) es un componente de MySQL que permite ejecutar estas tareas automatizadas. Es responsable de gestionar todos los eventos definidos en el servidor.

#### 3.2.2. Verificar el estado del planificador de eventos

Antes de trabajar con eventos, es necesario asegurarse de que el planificador esté habilitado. Puedes verificar su estado con el siguiente comando:

```sql
SHOW VARIABLES LIKE 'event_scheduler';
```

**Salida esperada**:

- `ON`: El planificador está habilitado y ejecutando eventos.  
- `OFF`: El planificador está deshabilitado.  
- `DISABLED`: El planificador está deshabilitado por completo (requiere reiniciar el servidor para cambiar este estado).

#### 3.2.3. Habilitar o deshabilitar el planificador de eventos

Puedes habilitar o deshabilitar el planificador dinámicamente o en la configuración del servidor.

1. **Habilitar/Deshabilitar dinámicamente**:

    Para habilitar el planificador:

    ```sql
    SET GLOBAL event_scheduler = ON;
    ```

    Para deshabilitarlo:

    ```sql
    SET GLOBAL event_scheduler = OFF;
    ```

    Hay que tener en cuenta que esta configuración se pierde si el servidor MySQL se reinicia.

2. **Habilitar/Deshabilitar de forma permanente**:

    Edita el archivo de configuración (`my.cnf` o `my.ini`) y añade:

    ```sql
    event_scheduler = ON
    ```

    Se debe reiniciar el servidor MySQL para aplicar los cambios.

#### 3.2.4. Consideraciones sobre el planificador de eventos

- El planificador consume recursos del servidor para ejecutar tareas, por lo que no es recomendable habilitarlo si no hay eventos definidos.  
- Es importante supervisar el uso de eventos recurrentes para evitar sobrecargar el servidor.

### 3.3. Creación de Eventos

#### 3.3.1. Sintaxis básica para crear eventos

La sintaxis completa para la creación de un evento en mysql es la siguiente:

```sql
CREATE
    [DEFINER = user]
    EVENT
    [IF NOT EXISTS]
    event_name
    ON SCHEDULE schedule
    [ON COMPLETION [NOT] PRESERVE]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT 'string']
    DO event_body;

schedule: {
    AT timestamp [+ INTERVAL interval] ...
  | EVERY interval
    [STARTS timestamp [+ INTERVAL interval] ...]
    [ENDS timestamp [+ INTERVAL interval] ...]
}

interval:
    quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |
              WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |
              DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}
```

En su sintaxis más básica:

```sql
CREATE EVENT nombre_evento
ON SCHEDULE tipo_programacion
DO
    instruccion_sql;
```

**Partes clave**:

- **`nombre_evento`**: Nombre único del evento en la base de datos.  
- **`ON SCHEDULE`**: Define el momento y la frecuencia de ejecución.  
- **`DO`**: Contiene la instrucción SQL que se ejecutará.

#### 3.3.2. Tipos de programación

1. **Ejecución única**: se usa `AT` para definir una fecha y hora específica.

    ```sql
    CREATE EVENT evento_unico
    ON SCHEDULE AT '2024-01-15 10:00:00'
    DO
        DELETE FROM logs WHERE fecha < '2023-12-31';
    ```

2. **Ejecución recurrente**: se usa `EVERY` para definir un intervalo y opcionalmente un tiempo de inicio.

    ```sql
    CREATE EVENT evento_recurrente
    ON SCHEDULE EVERY 1 DAY
    STARTS '2024-01-01 00:00:00'
    ENDS '2024-12-31 23:59:59'
    DO
        DELETE FROM logs WHERE fecha < DATE_SUB(CURDATE(), INTERVAL 30 DAY);
    ```

**Nota**: Si no se especifica `STARTS`, el evento comienza inmediatamente.

#### 3.3.3. Opciones adicionales en la creación de eventos

1. **Habilitación/Deshabilitación del evento**: por defecto, un evento se crea habilitado (`ENABLE`), pero puedes deshabilitarlo con:

    ```sql
    CREATE EVENT nombre_evento
    ON SCHEDULE EVERY 1 HOUR
    DISABLE
    DO
        DELETE FROM logs WHERE fecha < CURDATE();
    ```

2. **Preservar el evento después de la ejecución**: por defecto, los eventos de ejecución única se eliminan tras ejecutarse (`ON COMPLETION NOT PRESERVE`).

    ```sql
    CREATE EVENT nombre_evento
    ON SCHEDULE AT '2024-01-15 10:00:00'
    ON COMPLETION PRESERVE
    DO
        DELETE FROM logs WHERE fecha < '2023-12-31';
    ```

#### 3.3.4. Verificar eventos creados

Los eventos en MySQL **se almacenan en el esquema del sistema** y puedes verlos utilizando comandos específicos o consultando las tablas adecuadas en el esquema **`information_schema`**. Los eventos definidos en una base de datos se guardan en la tabla **`EVENTS`** dentro del esquema del sistema **`information_schema`**. Esta tabla almacena toda la información sobre los eventos, como su nombre, estado, programación, y la última vez que se ejecutaron.

**Cómo listar y ver eventos creados:**

1. Usar `SHOW EVENTS`:  el comando `SHOW EVENTS` te permite listar todos los eventos creados en una base de datos específica.

    ```sql
    SHOW EVENTS FROM nombre_base_datos;
    ```

    **Salida esperada:**

    ```plaintext
    +-------------------+-----------------+---------+------------+-------------+-----------+
    | Db                | Name            | Definer | Time zone  | Type        | Status    |
    +-------------------+-----------------+---------+------------+-------------+-----------+
    | nombre_base_datos | limpiar_logs    | root@%  | SYSTEM     | RECURRING   | ENABLED   |
    | nombre_base_datos | reporte_semanal | root@%  | SYSTEM     | ONE TIME    | COMPLETED |
    +-------------------+-----------------+---------+------------+-------------+-----------+
    ```

    - **`Db`**: Base de datos donde está definido el evento.  
    - **`Name`**: Nombre del evento.  
    - **`Type`**: Si es de ejecución única (`ONE TIME`) o recurrente (`RECURRING`).  
    - **`Status`**: Estado actual del evento (`ENABLED`, `DISABLED`, `COMPLETED`).

2. Consultar la tabla `information_schema.EVENTS`: si necesitas más detalles sobre los eventos, puedes consultar directamente la tabla **`information_schema.EVENTS`**.

    ```sql
    SELECT EVENT_NAME, EVENT_DEFINITION, STATUS, STARTS, ENDS, LAST_EXECUTED
    FROM information_schema.EVENTS
    WHERE EVENT_SCHEMA = 'nombre_base_datos';
    ```

    **Salida esperada:**

    ```plaintext
    +-----------------+-------------------------+-----------+---------------------+---------+---------------------+
    | EVENT_NAME      | EVENT_DEFINITION        | STATUS    | STARTS              | ENDS    | LAST_EXECUTED       |
    +-----------------+-------------------------+-----------+---------------------+---------+---------------------+
    | limpiar_logs    | DELETE FROM logs ...    | ENABLED   | 2024-01-01 00:00:00 | NULL    | 2024-01-08 00:00:00 |
    | reporte_semanal | CALL generar_reporte(); | COMPLETED | NULL                | NULL    | 2024-01-07 23:59:59 |
    +-----------------+-------------------------+-----------+---------------------+---------+---------------------+
    ```

**Columnas importantes**:

- **`EVENT_NAME`**: Nombre del evento.  
- **`EVENT_DEFINITION`**: La instrucción SQL que ejecuta el evento.  
- **`STATUS`**: Estado del evento (`ENABLED`, `DISABLED`, o `COMPLETED`).  
- **`STARTS`** y **`ENDS`**: Momentos de inicio y fin de la programación.  
- **`LAST_EXECUTED`**: Última vez que se ejecutó el evento.

Puedes filtrar eventos según su estado o programación. Por ejemplo, listar sólo los eventos activos:

```sql
SELECT EVENT_NAME, STATUS, LAST_EXECUTED
FROM information_schema.EVENTS
WHERE EVENT_SCHEMA = 'nombre_base_datos' AND STATUS = 'ENABLED';
```

Hay que tener en cuenta que:

- Cada base de datos puede tener sus propios eventos definidos.  
- Los eventos no son compartidos entre bases de datos; están asociados exclusivamente a la base de datos donde se crean.

#### 3.3.5. Ejemplo práctico

Un evento recurrente que limpia registros antiguos cada semana:

```sql
CREATE EVENT limpiar_logs_semanal
ON SCHEDULE EVERY 1 WEEK
STARTS '2024-01-01 00:00:00'
DO
    DELETE FROM logs WHERE fecha < DATE_SUB(CURDATE(), INTERVAL 90 DAY);
```

Para verificar su creación:

```sql
SHOW EVENTS FROM nombre_base_datos;
```

### 3.4. Modificación de Eventos

Los eventos en MySQL pueden modificarse usando el comando **`ALTER EVENT`**. Este comando permite cambiar cualquier aspecto del evento, como su programación, estado, o incluso la instrucción que ejecuta.

#### 3.4.1. Sintaxis básica de ALTER EVENT

```sql
ALTER EVENT nombre_evento
[ON SCHEDULE nuevo_horario]
[RENAME TO nuevo_nombre]
[ENABLE | DISABLE]
[DO nueva_instruccion];
```

#### 3.4.2. Opciones disponibles para modificar un evento

**Cambiar la programación (`ON SCHEDULE`)**: Puedes modificar la hora o frecuencia de ejecución del evento.

```sql
ALTER EVENT limpiar_logs
ON SCHEDULE EVERY 1 MONTH
STARTS '2024-02-01 00:00:00';
```

**Cambiar el nombre del evento (`RENAME TO`)**: Si necesitas renombrar un evento:

```sql
ALTER EVENT limpiar_logs
RENAME TO limpiar_logs_mensual;
```

**Habilitar o deshabilitar un evento (`ENABLE` o `DISABLE`)**:

1. **`ENABLE`**: Activa el evento para que se ejecute según su programación.  
2. **`DISABLE`**: Desactiva el evento, deteniendo su ejecución.

```sql
ALTER EVENT limpiar_logs DISABLE;
```

**Cambiar la instrucción que ejecuta el evento (`DO`)**: Modifica la lógica que se ejecuta dentro del evento.

```sql
ALTER EVENT limpiar_logs
DO
    DELETE FROM logs WHERE fecha < DATE_SUB(CURDATE(), INTERVAL 60 DAY);
```

#### 3.4.3. Ejemplo completo: Modificar un evento

Supongamos que tienes un evento que borra registros antiguos cada semana. Ahora quieres:

- Cambiar su frecuencia a una vez al mes.  
- Actualizar la instrucción para conservar registros más antiguos.

**Antes (definición original del evento):**

```sql
CREATE EVENT limpiar_logs
ON SCHEDULE EVERY 1 WEEK
DO
    DELETE FROM logs WHERE fecha < DATE_SUB(CURDATE(), INTERVAL 30 DAY);
```

**Modificación:**

```sql
ALTER EVENT limpiar_logs
ON SCHEDULE EVERY 1 MONTH
DO
    DELETE FROM logs WHERE fecha < DATE_SUB(CURDATE(), INTERVAL 90 DAY);
```

**Resultado esperado:** El evento ahora se ejecutará mensualmente y conservará registros de hasta 90 días de antigüedad.

### 3.5. Eliminación de Eventos

Cuando un evento ya no es necesario, puedes eliminarlo del sistema utilizando el comando **`DROP EVENT`**.

#### 3.5.1. Sintaxis básica de `DROP EVENT`

```sql
DROP EVENT [IF EXISTS] nombre_evento;
```

**`IF EXISTS`**: Evita errores si el evento no existe.

#### 3.5.2. Ejemplo básico

Eliminar un evento llamado `limpiar_logs`:

```sql
DROP EVENT limpiar_logs;
```

Si el evento no existe, el comando generará un error. Para evitar esto:

```sql
DROP EVENT IF EXISTS limpiar_logs;
```

#### 3.5.3. Consideraciones importantes al eliminar eventos

1. **Impacto en procesos automatizados**:  
   - Antes de eliminar un evento, asegúrate de que ninguna operación dependiente quede afectada.  
   - Revisa la tabla **`information_schema.EVENTS`** para confirmar el propósito del evento.  
2. **Eliminación permanente**:  
   - Una vez eliminado, no se puede recuperar el evento ni su programación. Si crees que puede ser necesario en el futuro, considera deshabilitarlo en lugar de eliminarlo:

    ```sql
    ALTER EVENT nombre_evento DISABLE;
    ```

### 3.6. Privilegios Relacionados con Eventos

Para trabajar con eventos en MySQL, los usuarios deben tener ciertos privilegios específicos, además de permisos generales para las bases de datos afectadas.

#### 3.6.1. Privilegios necesarios

1. **`EVENT`**:  
   - Permite al usuario crear, modificar y eliminar eventos en una base de datos.  
   - Este privilegio debe asignarse explícitamente.

    ```sql
    GRANT EVENT ON nombre_base_datos.* TO 'usuario'@'localhost';
    ```

2. **`CREATE` y `ALTER` en las tablas afectadas**:  
   - Si el evento modifica datos en una tabla, el usuario también necesita permisos para operar en esas tablas (por ejemplo, `INSERT`, `UPDATE`, `DELETE`).  

3. **`SUPER` (en casos avanzados)**:  
   - Es necesario si un evento utiliza privilegios elevados o modifica variables globales.

#### 3.6.2. Verificar privilegios de un usuario

Como recordatorio, para verificar los privilegios actuales de un usuario:

```sql
SHOW GRANTS FOR 'usuario'@'localhost';
```

#### 3.6.3. Restricciones de seguridad

1. **Eventos creados por usuarios específicos**:
   - Los eventos están asociados al "definer" (creador del evento). Si el usuario que creó el evento pierde sus privilegios, el evento puede dejar de funcionar. Revisa el campo **`DEFINER`** en `information_schema.EVENTS` para identificar al creador:

    ```sql
    SELECT EVENT_NAME, DEFINER FROM information_schema.EVENTS WHERE EVENT_SCHEMA = 'nombre_base_datos';
    ```

2. **Revocar privilegios**: Si necesitas evitar que un usuario administre eventos, puedes revocar el privilegio `EVENT`:

    ```sql
    REVOKE EVENT ON nombre_base_datos.* FROM 'usuario'@'localhost';
    ```

### 3.7. Consideraciones de Seguridad y Rendimiento en Eventos

El uso de eventos en MySQL puede tener un impacto significativo en la seguridad y el rendimiento del servidor. Una gestión adecuada ayuda a garantizar que los eventos no comprometan la integridad de los datos ni sobrecarguen el sistema.

#### 3.7.1. Consideraciones de Seguridad

**Evita privilegios excesivos**:

- Los eventos heredan los privilegios del usuario que los define (**`DEFINER`**).  
- Asegúrate de que el usuario **definer** tenga solo los permisos necesarios para la tarea del evento. Revisa el campo **`DEFINER`** en `information_schema.EVENTS`:

    ```sql
    SELECT EVENT_NAME, DEFINER FROM information_schema.EVENTS WHERE EVENT_SCHEMA = 'nombre_base_datos';
    ```

**Restricción de acceso a eventos**: Solo asigna el privilegio `EVENT` a usuarios que realmente necesiten crear o administrar eventos.

**Validación de instrucciones SQL en eventos**:

- Asegúrate de que las instrucciones dentro de los eventos sean seguras y no permitan inyecciones SQL.  
- Usa variables o valores controlados en las consultas.

#### 3.7.2. Consideraciones de Rendimiento

1. **Impacto de eventos recurrentes**:  
   - Eventos que se ejecutan con demasiada frecuencia (por ejemplo, cada segundo) pueden sobrecargar el servidor.  
   - Usa intervalos razonables (`EVERY 1 HOUR`, `EVERY 1 DAY`) para minimizar el impacto.  
2. **Uso eficiente de recursos**:  
   - Evita que los eventos realicen operaciones complejas o que bloqueen tablas por largos períodos.  
   - Opta por operaciones por lotes si el evento afecta grandes cantidades de datos.  
3. **Planificador de eventos (`event_scheduler`)**:  
   - El planificador debe estar habilitado solo si hay eventos configurados.  
   - Monitoriza su uso y ajusta la configuración si observas un impacto negativo en el rendimiento.  
4. **Supervisión de eventos en ejecución**:  
   - Usa la columna **`LAST_EXECUTED`** en `information_schema.EVENTS` para verificar si los eventos se están ejecutando correctamente.  
   - Identifica retrasos en la ejecución o problemas con eventos deshabilitados.

### 3.8. Ejemplos Prácticos de Uso de Eventos

Los eventos en MySQL tienen aplicaciones prácticas en una variedad de escenarios. Aquí te dejo ejemplos para diferentes casos de uso:

#### 3.8.1. Limpieza Automática de Registros Antiguos

Este evento elimina registros de la tabla `logs` que sean más antiguos de 90 días. Se ejecuta automáticamente cada semana.

**Definición del evento:**

```sql
CREATE EVENT limpiar_logs_semanal
ON SCHEDULE EVERY 1 WEEK
STARTS '2024-01-01 00:00:00'
DO
    DELETE FROM logs WHERE fecha < DATE_SUB(CURDATE(), INTERVAL 90 DAY);
```

**Verificación del evento:**

```sql
SHOW EVENTS FROM nombre_base_datos;
```

#### 3.8.2. Generación de Informes Periódicos

Un evento que ejecuta un procedimiento para generar un informe semanal y guarda los resultados en la tabla `reportes`.

**Definición del procedimiento:**

```sql
CREATE PROCEDURE generar_reporte()
BEGIN
    INSERT INTO reportes (fecha_generacion, total_ventas)
    SELECT CURDATE(), SUM(importe) FROM ventas WHERE fecha = CURDATE();
END;
```

**Definición del evento:**

```sql
CREATE EVENT reporte_semanal
ON SCHEDULE EVERY 1 WEEK
STARTS '2024-01-01 00:00:00'
DO
    CALL generar_reporte();
```

#### 3.8.3. Reseteo Automático de una Tabla Temporal

Un evento que vacía la tabla `temp_sesiones` cada noche para liberar espacio y mantenerla limpia.

**Definición del evento:**

```sql
CREATE EVENT limpiar_sesiones
ON SCHEDULE EVERY 1 DAY
STARTS '2024-01-01 02:00:00'
DO
    TRUNCATE TABLE temp_sesiones;
```

Como recordatorio, la sentencia `TRUNCATE` vacía por completo una tabla (requiere de permisos de eliminación 'DROP'), y seróia equivalente a la secuencia `DROP TABLE` y `CREATE TABLE`.

#### 3.8.4. Deshabilitación Temporal de Eventos

Un DBA deshabilita temporalmente un evento mientras realiza tareas de mantenimiento.

**Comando para deshabilitar:**

```sql
ALTER EVENT limpiar_logs_semanal DISABLE;
```

**Comando para habilitar nuevamente:**

```sql
ALTER EVENT limpiar_logs_semanal ENABLE;
```

## 4. Introducción a los Disparadores

### 4.1. ¿Qué son los disparadores?

Un **disparador (trigger)** es una rutina almacenada en el servidor MySQL que se ejecuta automáticamente en respuesta a un evento específico en una tabla. Estos eventos pueden ser:

- **`INSERT`**: Cuando se inserta una nueva fila.  
- **`UPDATE`**: Cuando se modifica una fila existente.  
- **`DELETE`**: Cuando se elimina una fila.

Los disparadores están diseñados para operar **por cada fila** afectada por el evento. Esto significa que, en una operación que afecta múltiples filas, el disparador se ejecutará tantas veces como filas estén involucradas.

**¿Cuándo se usan los disparadores?**

Los disparadores son útiles para automatizar tareas y garantizar la integridad de los datos. Algunos casos comunes incluyen:

1. **Auditoría de datos**:  
   - Registrar automáticamente cambios realizados en una tabla (por ejemplo, quién y cuándo modificó una fila).  
2. **Sincronización de tablas**:  
   - Actualizar automáticamente una tabla secundaria cuando se realizan cambios en la tabla principal.  
3. **Validación de datos**:  
   - Evitar que se inserten datos inválidos o inconsistentes.  
4. **Lógica de negocio**:  
   - Implementar reglas específicas del negocio que deban ejecutarse automáticamente.

**Ventajas y desventajas de los disparadores:**

| Ventajas | Desventajas |
| ----- | ----- |
| Automatizan tareas repetitivas. | Dificultan la depuración de errores si son complejos. |
| Garantizan consistencia y reglas del negocio. | Pueden impactar el rendimiento en tablas grandes. |
| Son invisibles para las aplicaciones externas. | Aumentan la complejidad si no se documentan bien. |

### 4.2. Creación de Disparadores

En su sintaxis más simple, esta sería la forma de crear un disparador en mysql:

```sql
CREATE TRIGGER nombre_disparador
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON nombre_tabla
FOR EACH ROW
BEGIN
    -- Instrucciones SQL que ejecuta el disparador
END;
```

**Descripción de los componentes:**

1. **`nombre_disparador`**:  
   - Nombre único para el disparador dentro de la base de datos y tabla.  
2. **`BEFORE` o `AFTER`**:  
   - **`BEFORE`**: Se ejecuta **antes** de que se aplique el cambio en la tabla.  
     - Ideal para validaciones o cálculos previos.  
   - **`AFTER`**: Se ejecuta **después** de que el cambio ha sido aplicado.  
     - Útil para registrar cambios o sincronizar tablas.  
3. **`INSERT`, `UPDATE`, `DELETE`**:  
   - Evento que activa el disparador.  
   - Cada disparador puede estar asociado a **un solo evento**.  
4. **`ON nombre_tabla`**:  
   - Tabla en la que se define el disparador.  
5. **`FOR EACH ROW`**:  
   - Indica que el disparador se ejecutará una vez por cada fila afectada.  
6. **Pseudotablas (`NEW` y `OLD`)**:  
   - **`NEW`**: Contiene los valores nuevos (solo disponible en `INSERT` y `UPDATE`).  
   - **`OLD`**: Contiene los valores antiguos (solo disponible en `DELETE` y `UPDATE`).

A continuación, se presentan algunos ejemplos de disparadores:

**Ejemplo 1: Auditoría de cambios en una tabla.**

Registrar automáticamente los cambios realizados en la tabla `clientes`.

```sql
CREATE TRIGGER auditoria_actualizacion_cliente
AFTER UPDATE
ON clientes
FOR EACH ROW
BEGIN
    INSERT INTO auditoria_clientes (id_cliente, accion, fecha_cambio, detalle_cambio)
    VALUES (OLD.id_cliente, 'UPDATE', NOW(),
            CONCAT('Nombre cambiado de ', OLD.nombre, ' a ', NEW.nombre));
END;
```

- **Propósito**: registra quién actualizó un cliente y detalla los cambios realizados.

**Ejemplo 2: Validación previa a una operación.**

Evitar que se inserten productos con precios negativos en la tabla `productos`.

```sql
CREATE TRIGGER validar_precio_producto
BEFORE INSERT
ON productos
FOR EACH ROW
BEGIN
    IF NEW.precio < 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'El precio del producto no puede ser negativo';
    END IF;
END;
```

- **Propósito**: garantiza que no se ingresen datos inválidos en la tabla.

**Ejemplo 3: Sincronización entre tablas.**

Actualizar automáticamente el inventario cuando se realiza una venta.

```sql
CREATE TRIGGER actualizar_inventario
AFTER INSERT
ON ventas
FOR EACH ROW
BEGIN
    UPDATE inventario
    SET cantidad = cantidad - NEW.cantidad
    WHERE id_producto = NEW.id_producto;
END;
```

- **Propósito**: sincroniza la tabla `inventario` tras cada inserción en la tabla `ventas`.

#### 4.2.1. Consideraciones al crear disparadores

1. **Cantidad de disparadores por tabla**:  
   - Una tabla puede tener **un solo disparador por tipo de evento y momento**. Ejemplo:  
     - `BEFORE INSERT`  
     - `AFTER INSERT`  
     - `BEFORE UPDATE`, etc.  
2. **Órdenes dentro del disparador**:  
   - Los disparadores no pueden ejecutar **`COMMIT`**, **`ROLLBACK`** o instrucciones que modifiquen el estado de la transacción.  
3. **Evitar ciclos de disparadores**:  
   - Un disparador no debe causar la ejecución de otro disparador que produzca un ciclo infinito.

#### 4.2.2. Errores comunes al crear disparadores

**Falta de delimitadores**: los disparadores contienen bloques `BEGIN...END`, lo que requiere cambiar el delimitador antes de crearlos, como hemos visto con la creación de funciones y procedimientos.

**Confundir `NEW` y `OLD`**: Usar pseudotablas incorrectamente, como intentar acceder a `OLD` en un `INSERT`. Estas son las combinaciones posibles

| Acción | Pseudotabla | Descripción |
| ----- | ----- | ----- |
| `INSERT` | `NEW` | Contiene los valores de las nuevas filas que se están insertando. |
| `UPDATE` | `NEW` | Contiene los valores de las nuevas filas después de la actualización. |
| `UPDATE` | `OLD` | Contiene los valores de las filas antes de la actualización. |
| `DELETE` | `OLD` | Contiene los valores de las filas que se están eliminando. |

**Ausencia de permisos**: Asegúrate de que el usuario tiene el privilegio **`TRIGGER`**:

```sql
GRANT TRIGGER ON nombre_base_datos.* TO 'usuario'@'localhost';
```

### 4.3. Modificación, eliminación y muestra de disparadores

Podemos comprobar qué disparadores tiene una base de datos mediante la sentencia

```sql
SHOW TRIGGERS
    [{FROM | IN} db_name]
    [LIKE 'pattern' | WHERE expr]
```

Podemos filtrar los triggers haciendo uso de la expresion **LIKE** 'pattern', donde 'pattern' servirá para indicar el nombre de las tablas afectadas (no del propio trigger), o **WHERE** para filtrar por filas.

También lo podemos hacer mediante una consulta a la tabla TRIGGERS de information\_schema:

```sql
SELECT TRIGGER_NAME, EVENT_MANIPULATION, ACTION_STATEMENT
FROM information_schema.TRIGGERS
WHERE TRIGGER_SCHEMA = 'nombre_base_datos' AND EVENT_OBJECT_TABLE = 'nombre_tabla';
```

MySQL no proporciona una sentencia para modificar un disparador, por lo que tendremos que eliminarlo y volverlo a crear. Localizaremos el trigger que deseamos modificar mediante alguno de los métodos anteriores, y lo eliminaremos mediante la sentencia

```sql
DROP TRIGGER [IF EXISTS] nombre_disparador;
```

Luego podremos crearlo de nuevo haciendo los cambios que consideremos necesarios.

## 5. Gestión de Errores y Condiciones (Handlers)

### 5.1. Introducción a la Gestión de Errores

#### 5.1.1. Qué son las condiciones y los handlers

En MySQL, una **condición** es cualquier situación específica que puede ocurrir durante la ejecución de código SQL, como:

- **Errores** (división por cero, violación de clave única...)  
- **Advertencias** (truncamiento de datos, conversión de tipos...)  
- **Situaciones especiales** (no se encontraron más registros...)

Un **handler** (literalmente, manejador) es un bloque de código que especifica qué hacer cuando ocurre una condición determinada. Es similar al bloque try-catch en otros lenguajes de programación.

#### 5.1.2. Importancia del manejo de errores en bases de datos

El manejo adecuado de errores es crucial en bases de datos por varios motivos:

- **Integridad de datos**: Asegura que los datos permanezcan consistentes incluso cuando ocurren errores.

    ```sql
    -- Ejemplo: Transferencia bancaria
    BEGIN
        DECLARE error_found BOOLEAN DEFAULT FALSE;
        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET error_found = TRUE;
        
        UPDATE cuentas SET saldo = saldo - 1000 WHERE id = 1;
        UPDATE cuentas SET saldo = saldo + 1000 WHERE id = 2;
        
        IF error_found THEN
            ROLLBACK;
            SELECT 'Error en la transferencia';
        ELSE
            COMMIT;
            SELECT 'Transferencia exitosa';
        END IF;
    END;
    ```

- **Experiencia de usuario**: Proporciona mensajes de error significativos en lugar de fallos catastróficos.  
- **Mantenibilidad**: Facilita la depuración y el diagnóstico de problemas.  
- **Robustez**: Hace que las aplicaciones sean más resistentes a condiciones inesperadas.

#### 5.1.3. Diferencia entre errores y advertencias en MySQL

**Errores**: Son condiciones graves que impiden que una operación se complete.

- Código de error positivo  
- Detienen la ejecución (si no se manejan)  
- Ejemplo: Error 1062 (Violación de clave duplicada)

**Advertencias**: Son condiciones menos graves que permiten que la operación continúe.

- No detienen la ejecución  
- Se pueden consultar con `SHOW WARNINGS`  
- Ejemplo: Truncamiento de datos en una inserción

### 5.2. Declaración y Sintaxis

#### 5.2.1. Estructura básica DECLARE ... HANDLER

La sintaxis básica para declarar un handler es:

```sql
DECLARE [tipo_acción] HANDLER 
FOR [condición(es)]
[bloque_de_código]
```

- **`tipo_acción`**: especifica qué debe hacer MySQL cuando encuentra la condición:
  - **CONTINUE**: Ejecuta el bloque `bloque_de_código` del handler y continúa con la ejecución normal:

    ```sql
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        SET @error = 'Ha ocurrido un error';
    ```

  - **EXIT**: Ejecuta el bloque `bloque_de_código` del handler y termina la ejecución del bloque actual:

    ```sql
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET @error = 'Error - operación cancelada';
    END;
    ```

- **`condición(es)`**: indicamos la condicion (excepción, advertencia o situación excepcional) que queremos gestionar. Puede especificarse de varias formas:
  - **Valor único**:

    ```sql
    -- Usando código de error específico
    DECLARE CONTINUE HANDLER FOR 1062 
        SET @mensaje = 'Registro duplicado';
    ```

  - **Lista de valores**:

    ```sql
    -- Múltiples códigos de error
    DECLARE CONTINUE HANDLER FOR 1051, 1146, 1052
        SET @mensaje = 'Error en la estructura de tabla';
    ```

  - **Condición predefinida**:

    ```sql
    DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET @fin = TRUE;
    ```

- **Bloque de Código**: son la sentencia o conjunto de sentencias SQL que queremos que se ejecuten cuando sucede la condición indicada. Puede ser:
  - Una única instrucción  
  - Un bloque **`BEGIN .. END`** con múltiples instrucciones

    ```sql
    -- Instrucción única
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        SET @error = TRUE;

    -- Bloque múltiple
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET @error = TRUE;
        SET @mensaje = 'Error en la operación';
        ROLLBACK;
    END;
    ```

#### 5.2.2. Ámbito de los handlers y reglas de declaración

**Ubicación**: Los handlers deben declararse:

- Después de las declaraciones de variables y condiciones  
- Antes de cualquier otra sentencia ejecutable  
- Dentro del bloque donde se utilizarán

**Orden de Precedencia**:

- Se ejecuta el handler más específico que coincida con la condición  
- Si hay varios handlers para la misma condición, se usa el último declarado

```sql
DELIMITER //
CREATE PROCEDURE ejemplo_ambito()
BEGIN
    -- 1. Primero: Variables
    DECLARE v_error BOOLEAN DEFAULT FALSE;
    DECLARE v_mensaje VARCHAR(100);
    
    -- 2. Segundo: Condiciones personalizadas (si las hay)
    DECLARE error_custom CONDITION FOR 1062;
    
    -- 3. Tercero: Handlers
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET v_error = TRUE;
        SET v_mensaje = 'Error SQL general';
    END;
    
    -- 4. Finalmente: Código ejecutable
    START TRANSACTION;
    -- ... resto del código
END //
DELIMITER ;
```

A continuación se presenta un ejemplo completo con diferentes niveles de ámbito:

```sql
DELIMITER //
CREATE PROCEDURE gestionar_empleado(p_id INT)
BEGIN
    -- Bloque principal
    DECLARE v_error BOOLEAN DEFAULT FALSE;
    
    -- Handler para el bloque principal
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET v_error = TRUE;
        ROLLBACK;
    END;
    
    START TRANSACTION;
    
    BEGIN  -- Sub-bloque
        -- Variables locales al sub-bloque
        DECLARE v_salario DECIMAL(10,2);
        
        -- Handler específico para este sub-bloque
        DECLARE CONTINUE HANDLER FOR 1365
        BEGIN
            SET v_salario = 0;
        END;
        
        -- Código del sub-bloque
        SELECT salario INTO v_salario 
        FROM empleados 
        WHERE id = p_id;
        
    END;  -- Fin sub-bloque
    
    IF v_error THEN
        SELECT 'Operación fallida' AS resultado;
    ELSE
        COMMIT;
        SELECT 'Operación exitosa' AS resultado;
    END IF;
    
END //
DELIMITER ;
```

### 5.3. Tipos de Condiciones

A continuación se detallan algunas de las condiciones más comunes a gestionar en SQL.

#### 5.3.1. SQLEXCEPTION

Engloba todos los errores (condiciones con códigos de error positivos). Se usa para capturar cualquier error SQL:

```sql
DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
BEGIN
    -- Código para manejar el error
    SET @error_msg = 'Ha ocurrido un error SQL';
    ROLLBACK;
END;
```

#### 5.3.2. SQLWARNING

Captura todas las advertencias MySQL:

```sql
DECLARE CONTINUE HANDLER FOR SQLWARNING
BEGIN
    -- Código para manejar la advertencia
    SET @warning_msg = 'Se ha producido una advertencia';
END;
```

#### 5.3.3. NOT FOUND

Se dispara cuando:

- Una `SELECT ... INTO` no encuentra registros  
- Un cursor llega al final del conjunto de resultados  
- Una `UPDATE` o `DELETE` no afecta a ninguna fila

```sql
DECLARE CONTINUE HANDLER FOR NOT FOUND
BEGIN
    SET done = TRUE;
END;
```

#### 5.3.4. Códigos de error específicos de MySQL

Podemos manejar errores específicos por su número:

```sql
-- Manejar error de clave duplicada
DECLARE CONTINUE HANDLER FOR 1062
BEGIN
    SET @error_msg = 'El registro ya existe';
END;

-- Manejar múltiples errores específicos
DECLARE CONTINUE HANDLER FOR 1051, 1146
BEGIN
    SET @error_msg = 'Problema con la estructura de la tabla';
END;
```

#### 5.3.5. Condiciones personalizadas (CONDITION)

Podemos crear nombres significativos para condiciones específicas:

```sql
-- Declarar una condición personalizada
DECLARE dup_entry CONDITION FOR 1062;

-- Usar la condición personalizada en un handler
DECLARE CONTINUE HANDLER FOR dup_entry
BEGIN
    SET @error_msg = 'Entrada duplicada detectada';
END;
```

### 5.4. Manejo de Errores en la Práctica

#### 5.4.1. Handlers en Procedimientos Almacenados

Los procedimientos almacenados son el lugar más común para usar handlers. Ejemplo típico:

```sql
DELIMITER //
CREATE PROCEDURE insertar_empleado(
    IN p_nombre VARCHAR(100),
    IN p_salario DECIMAL(10,2)
)
BEGIN
    -- Declaraciones
    DECLARE v_error_ocurrido BOOLEAN DEFAULT FALSE;
    DECLARE v_error_mensaje VARCHAR(100);

    -- Handlers
    DECLARE CONTINUE HANDLER FOR 1062
        SET v_error_mensaje = 'El empleado ya existe';
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET v_error_ocurrido = TRUE;
        SET v_error_mensaje = 'Error general en la operación';
    END;

    -- Operación principal
    INSERT INTO empleados(nombre, salario) 
    VALUES (p_nombre, p_salario);

    -- Control de resultados
    IF v_error_ocurrido THEN
        SELECT v_error_mensaje AS 'Error';
    ELSE
        SELECT 'Empleado insertado correctamente' AS 'Resultado';
    END IF;
END //
DELIMITER ;
```

#### 5.4.2. Handlers en Triggers

En triggers, los handlers son especialmente útiles para validar datos y mantener la integridad:

```sql
DELIMITER //
CREATE TRIGGER validar_salario
BEFORE INSERT ON empleados
FOR EACH ROW
BEGIN
    DECLARE v_salario_minimo DECIMAL(10,2);
    DECLARE v_error_mensaje VARCHAR(100);
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Error en validación de salario';
    END;

    SELECT MIN(salario) INTO v_salario_minimo 
    FROM rangos_salario 
    WHERE departamento = NEW.departamento;
    
    IF NEW.salario < v_salario_minimo THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Salario por debajo del mínimo permitido';
    END IF;
END //
DELIMITER ;
```

#### 5.4.3. Handlers en Bloques BEGIN-END

Los bloques BEGIN-END permiten agrupar lógica y manejar errores de forma localizada:

```sql
BEGIN
    DECLARE v_error BOOLEAN DEFAULT FALSE;
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET v_error = TRUE;

    BEGIN  -- Bloque interno
        DECLARE v_count INT;
        DECLARE error_en_conteo CONDITION FOR SQLSTATE '01000';
        DECLARE CONTINUE HANDLER FOR error_en_conteo 
            SET v_count = 0;

        -- Operaciones del bloque interno
        SELECT COUNT(*) INTO v_count FROM tabla_ejemplo;
    END;

    IF v_error THEN
        -- Manejar error del bloque externo
    END IF;
END;
```

#### 5.4.4. Handlers con Cursores

Los handlers son esenciales cuando trabajamos con cursores. Éstos los veremos en el siguiente apartado.

### 5.5. Buenas Prácticas

#### 5.5.1. Estrategias de Gestión de Errores

La gestión efectiva de errores en MySQL requiere un enfoque estructurado:

1. **Jerarquía de Handlers**:
   - Handlers específicos para errores conocidos
   - Handler general para SQLEXCEPTION como respaldo

2. **Transacciones**:
   - Usar siempre que se modifiquen múltiples tablas
   - Implementar rollback en caso de error

3. **Variables de Control**:
   - Mantener flags de estado
   - Almacenar mensajes de error descriptivos

```sql
BEGIN
    DECLARE v_error BOOLEAN DEFAULT FALSE;
    DECLARE v_error_msg VARCHAR(100);
    
    DECLARE CONTINUE HANDLER FOR 1062 
    BEGIN
        SET v_error = TRUE;
        SET v_error_msg = 'Registro duplicado';
    END;
    
    -- ... código ...
    
    IF v_error THEN
        -- Manejar error
    END IF;
END;
```

#### 5.5.2. Logging de Errores

Es buena práctica mantener un registro de errores para diagnóstico y seguimiento:

```sql
CREATE TABLE error_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    procedimiento VARCHAR(100),
    codigo_error INT,
    mensaje VARCHAR(500),
    datos_entrada JSON
);

-- Ejemplo de uso
DELIMITER //
CREATE PROCEDURE insertar_con_log(IN p_datos JSON)
BEGIN
    DECLARE v_error_code INT;
    DECLARE v_error_msg VARCHAR(500);
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1
            v_error_code = MYSQL_ERRNO,
            v_error_msg = MESSAGE_TEXT;
            
        INSERT INTO error_log(procedimiento, codigo_error, mensaje, datos_entrada)
        VALUES (
            'insertar_con_log',
            v_error_code,
            v_error_msg,
            p_datos
        );
    END;
    
    -- Código principal...
END //
DELIMITER ;
```

#### 5.5.3. Depuración y Troubleshooting

Técnicas efectivas para identificar y resolver problemas:

1. **Usar Variables de Diagnóstico**:
```sql
GET DIAGNOSTICS CONDITION 1
    @errno = MYSQL_ERRNO,
    @msg = MESSAGE_TEXT;
```

2. **Crear Puntos de Control**:
```sql
SET @debug_point = 'Inicio proceso';
-- ... código ...
SET @debug_point = 'Después de primera operación';
```

3. **Logging Detallado**:
```sql
CREATE PROCEDURE debug_proceso()
BEGIN
    DECLARE v_step VARCHAR(100);
    
    SET v_step = 'Iniciando proceso';
    INSERT INTO debug_log(paso, timestamp) VALUES (v_step, NOW());
    
    -- ... código ...
    
    SET v_step = 'Proceso completado';
    INSERT INTO debug_log(paso, timestamp) VALUES (v_step, NOW());
END;
```

#### 5.5.4. Casos Comunes y Soluciones Recomendadas

1. **Violación de Clave Única**:
```sql
DECLARE CONTINUE HANDLER FOR 1062
BEGIN
    -- Intentar actualizar en lugar de insertar
    UPDATE tabla SET campo = nuevo_valor WHERE clave = valor_clave;
END;
```

2. **Registros No Encontrados**:
```sql
DECLARE CONTINUE HANDLER FOR NOT FOUND
BEGIN
    -- Crear registro por defecto
    INSERT INTO tabla (campos) VALUES (valores_default);
END;
```

3. **Error de División por Cero**:
```sql
DECLARE CONTINUE HANDLER FOR 1365
BEGIN
    -- Asignar valor por defecto
    SET resultado = 0;
END;
```

### 5.6. Ejemplos Prácticos

#### 5.6.1. Manejo Básico de Errores

```sql
DELIMITER //
CREATE PROCEDURE ejemplo_basico(IN p_id INT)
BEGIN
    DECLARE v_error BOOLEAN DEFAULT FALSE;
    DECLARE v_mensaje VARCHAR(100);
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET v_error = TRUE;
        SET v_mensaje = 'Error en la operación';
    END;
    
    -- Operación principal
    UPDATE clientes SET activo = 1 WHERE id = p_id;
    
    IF v_error THEN
        SELECT v_mensaje AS 'Error';
    ELSE
        SELECT 'Operación exitosa' AS 'Resultado';
    END IF;
END //
DELIMITER ;
```

#### 5.6.2. Gestión de Errores en Transacciones

```sql
DELIMITER //
CREATE PROCEDURE transferencia(
    IN p_origen INT,
    IN p_destino INT,
    IN p_cantidad DECIMAL(10,2)
)
BEGIN
    DECLARE v_error BOOLEAN DEFAULT FALSE;
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET v_error = TRUE;
        ROLLBACK;
    END;
    
    START TRANSACTION;
    
    UPDATE cuentas 
    SET saldo = saldo - p_cantidad 
    WHERE id = p_origen;
    
    UPDATE cuentas 
    SET saldo = saldo + p_cantidad 
    WHERE id = p_destino;
    
    IF v_error THEN
        SELECT 'Error en la transferencia' AS 'Error';
    ELSE
        COMMIT;
        SELECT 'Transferencia exitosa' AS 'Resultado';
    END IF;
END //
DELIMITER ;
```

#### 5.6.3. Logging de Errores en Tabla

```sql
DELIMITER //
CREATE PROCEDURE operacion_con_log(IN p_data JSON)
BEGIN
    DECLARE v_inicio TIMESTAMP;
    DECLARE v_fin TIMESTAMP;
    DECLARE v_resultado VARCHAR(10) DEFAULT 'OK';
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET v_resultado = 'ERROR';
        INSERT INTO error_log (
            operacion,
            fecha_inicio,
            fecha_fin,
            resultado,
            datos
        ) VALUES (
            'operacion_con_log',
            v_inicio,
            CURRENT_TIMESTAMP,
            v_resultado,
            p_data
        );
    END;
    
    SET v_inicio = CURRENT_TIMESTAMP;
    
    -- Código principal...
    
    SET v_fin = CURRENT_TIMESTAMP;
    
    -- Log de éxito
    IF v_resultado = 'OK' THEN
        INSERT INTO operaciones_log (
            operacion,
            fecha_inicio,
            fecha_fin,
            resultado,
            datos
        ) VALUES (
            'operacion_con_log',
            v_inicio,
            v_fin,
            v_resultado,
            p_data
        );
    END IF;
END //
DELIMITER ;
```

#### 5.6.4. Handlers Múltiples

```sql
DELIMITER //
CREATE PROCEDURE ejemplo_handlers_multiples()
BEGIN
    DECLARE v_error_tipo VARCHAR(50);
    DECLARE v_mensaje VARCHAR(100);
    
    -- Handler para duplicados
    DECLARE CONTINUE HANDLER FOR 1062
    BEGIN
        SET v_error_tipo = 'DUPLICADO';
        SET v_mensaje = 'Registro duplicado';
    END;
    
    -- Handler para tabla no existe
    DECLARE CONTINUE HANDLER FOR 1146
    BEGIN
        SET v_error_tipo = 'TABLA';
        SET v_mensaje = 'La tabla no existe';
    END;
    
    -- Handler para división por cero
    DECLARE CONTINUE HANDLER FOR 1365
    BEGIN
        SET v_error_tipo = 'CALCULO';
        SET v_mensaje = 'Error en cálculo';
    END;
    
    -- Handler general para otros errores
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET v_error_tipo = 'GENERAL';
        SET v_mensaje = 'Error no especificado';
    END;
    
    -- Código principal...
    
    IF v_error_tipo IS NOT NULL THEN
        INSERT INTO log_errores (tipo, mensaje)
        VALUES (v_error_tipo, v_mensaje);
    END IF;
END //
DELIMITER ;
```

## 6. Introducción a los Cursores

### 6.1. ¿Qué son los cursores?

Un **cursor** es una estructura de control que permite procesar fila por fila el resultado de una consulta SQL. Actúa como un **puntero** o **indicador** que se mueve a través del conjunto de resultados, permitiendo acceder y manipular cada registro de manera individual.

En el contexto de MySQL y la administración de bases de datos, los cursores son especialmente útiles cuando necesitamos realizar operaciones que no pueden resolverse con una única consulta SQL y requieren un procesamiento registro a registro.

### 6.2. ¿Cuándo y por qué usarlos?

Los cursores son útiles en situaciones específicas como:

1. Cuando necesitamos realizar **operaciones complejas** que dependen de los valores de cada fila.  
2. En procesos de migración de datos donde se requiere transformar información registro a registro.  
3. Para **generar informes** que requieren cálculos o lógica específica para cada registro.  
4. En situaciones donde necesitamos **tomar decisiones** basadas en el contenido de cada fila.

Sin embargo, es importante destacar que los cursores no siempre son la mejor solución, ya que pueden tener un impacto significativo en el rendimiento cuando se trabaja con grandes volúmenes de datos.

### 6.3. Tipos de Cursores

#### 6.3.1. Cursores implícitos

Los cursores implícitos son gestionados automáticamente por MySQL sin necesidad de declararlos explícitamente. Se utilizan en operaciones como:

- Sentencias UPDATE  
- Sentencias DELETE  
- Sentencias INSERT  
- Sentencias SELECT que devuelven un único registro

MySQL maneja internamente estos cursores y proporciona información sobre su estado a través de variables como:

```sql
ROW_COUNT() -- Número de filas afectadas
FOUND_ROWS() -- Número de filas encontradas
```

#### 6.3.2. Cursores Explícitos

Los cursores explícitos son aquellos que el programador define y controla directamente. En MySQL, estos cursores:

1. Deben declararse dentro de procedimientos almacenados o funciones  
2. Son de solo lectura (no se pueden actualizar los datos a través del cursor)  
3. No son scrollables (solo pueden avanzar hacia adelante)

A continuación, vamos a definir con detalle como crear y utlizar un cursor.

### 6.4. Creación y Uso de Cursores

Esta es la sintaxis general para declarar un cursor en mysql:

```sql
DECLARE cursor_name CURSOR FOR select_statement
```

Esta sentencia debe añadirse al cuerpo de una rutina, y sirve para obtener un mecanismo de control sobre los resultados obtenidos a través de la sentencia `select_statement`. Tal y como se indica en la documentación oficial:

- la sentencia **`SELECT`** definida no debe incluir la cláusula **`INTO`**
- La declaración del cursor debe aparecer antes de la declaración del handler y después de la declaración de variables y condiciones. Sobre los handler hablaremos en apartados posteriores.

Ejemplo básico de **declaración** de un cursor explícito dentro de un procedimiento:

```sql
DELIMITER //
CREATE PROCEDURE ejemplo_cursor()
BEGIN
    -- 1. Declaración de variables
    DECLARE v_nombre VARCHAR(100);
    DECLARE v_salario DECIMAL(10,2);
    DECLARE v_done BOOLEAN DEFAULT FALSE;

    -- 2. Declaración del cursor
    DECLARE cur_empleados CURSOR FOR
        SELECT nombre, salario 
        FROM empleados 
        WHERE departamento = 'IT';

    -- 3. Declaración del manejador de eventos
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;
```

Una vez declarado el cursor, necesitamos abrirlo para empezar a usarlo. La estructura típica es la siguiente:

```sql
-- 1. Abrir el cursor
    OPEN cur_empleados;

    -- 2. Bucle de lectura
    read_loop: LOOP
        -- Obtener siguiente fila
        FETCH cur_empleados INTO v_nombre, v_salario;
        
        -- Comprobar si hemos terminado
        IF v_done THEN
            LEAVE read_loop;
        END IF;

        -- Aquí procesamos los datos...
        -- Por ejemplo:
        IF v_salario < 30000 THEN
            INSERT INTO aumentos_pendientes(nombre, salario_actual)
            VALUES (v_nombre, v_salario);
        END IF;
    END LOOP;
```

Es muy importante cerrar el cursor cuando hayamos terminado de usarlo para liberar recursos:

```sql
-- Cerrar el cursor
    CLOSE cur_empleados;
END //
DELIMITER ;
```

Veamos ahora un ejemplo completo:

```sql
DELIMITER //
CREATE PROCEDURE actualizar_salarios_departamento(IN p_departamento VARCHAR(50))
BEGIN
    -- Declaración de variables
    DECLARE v_id INT;
    DECLARE v_salario DECIMAL(10,2);
    DECLARE v_anos_servicio INT;
    DECLARE v_done BOOLEAN DEFAULT FALSE;

    -- Declaración del cursor
    DECLARE cur_empleados CURSOR FOR
        SELECT id, salario, YEAR(CURDATE()) - YEAR(fecha_contratacion)
        FROM empleados
        WHERE departamento = p_departamento;

    -- Declaración del manejador de errores
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;

    -- Crear tabla temporal para log
    CREATE TEMPORARY TABLE IF NOT EXISTS log_actualizaciones (
        empleado_id INT,
        salario_anterior DECIMAL(10,2),
        salario_nuevo DECIMAL(10,2),
        fecha_modificacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    -- Abrir cursor
    OPEN cur_empleados;

    -- Bucle de procesamiento
    read_loop: LOOP
        -- Obtener siguiente empleado
        FETCH cur_empleados INTO v_id, v_salario, v_anos_servicio;

        -- Salir si no hay más registros
        IF v_done THEN
            LEAVE read_loop;
        END IF;

        -- Calcular nuevo salario basado en años de servicio
        IF v_anos_servicio >= 5 THEN
            -- Guardar log del cambio
            INSERT INTO log_actualizaciones (empleado_id, salario_anterior, salario_nuevo)
            VALUES (v_id, v_salario, v_salario * 1.1);

            -- Actualizar salario
            UPDATE empleados
            SET salario = v_salario * 1.1
            WHERE id = v_id;
        END IF;

    END LOOP;

    -- Cerrar cursor
    CLOSE cur_empleados;

    -- Mostrar resultados
    SELECT * FROM log_actualizaciones;
    
    -- Limpiar
    DROP TEMPORARY TABLE IF EXISTS log_actualizaciones;

END //
```

Recordamos que para utilizar el procedimiento definido en el ejemplo anterior, ejecutaríamos:

```sql
-- Llamar al procedimiento para un departamento específico
CALL actualizar_salarios_departamento('IT');
```

#### 6.4.1. Puntos Importantes a Recordar

1. **Orden de Declaración**: Las variables deben declararse antes que el cursor, y el manejador de eventos después del cursor.  
2. **Variables de FETCH**: El número y tipo de variables en el FETCH debe coincidir exactamente con las columnas seleccionadas en el cursor.  
3. **Manejo de Errores**: Siempre es importante incluir un manejador para NOT FOUND para evitar bucles infinitos.  
4. **Recursos**: No olvides cerrar el cursor cuando termines de usarlo.  
5. **Tablas Temporales**: Son útiles para almacenar resultados intermedios cuando procesas datos con cursores.

### 6.5. Características principales de los cursores explícitos en MySQL

#### 6.5.1. Son unidireccionales (forward-only)

Imagina que tienes un libro y sólo puedes leer las páginas avanzando hacia adelante, sin poder retroceder. Así funcionan los cursores en MySQL:

- Solo pueden moverse hacia adelante en el conjunto de resultados  
- Una vez que avanzas a la siguiente fila, no puedes volver a la anterior  
- El recorrido es secuencial: fila 1 → fila 2 → fila 3 → ...

```sql
-- Ejemplo de recorrido unidireccional
FETCH cursor_ejemplo INTO variable;  -- Lee fila 1
FETCH cursor_ejemplo INTO variable;  -- Lee fila 2
-- No hay manera de volver a leer la fila 1
```

#### 6.5.2. Son de solo lectura (read-only)

Es como tener un libro en PDF: puedes leer su contenido pero no puedes modificarlo. En los cursores:

- Puedes leer los datos de cada fila  
- No puedes modificar los datos mientras los lees con el cursor  
- Si necesitas actualizar datos, deberás hacerlo con una sentencia UPDATE separada

```sql
-- Correcto: Leer datos
FETCH mi_cursor INTO nombre, edad, salario;

-- Incorrecto: No se puede hacer esto
UPDATE CURRENT OF mi_cursor;  -- ❌ No permitido en MySQL
```

#### 6.5.3. No son actualizables

No puedes usar sentencias UPDATE o DELETE directamente sobre la fila actual del cursor. Si necesitas actualizar datos, debes:

- Leer los datos con el cursor  
- Guardar los valores en variables  
- Realizar un UPDATE normal usando esos valores

```sql
-- Ejemplo de cómo actualizar datos cuando usamos cursores
DELIMITER //
CREATE PROCEDURE actualizar_salarios()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE emp_id INT;
    DECLARE emp_salario DECIMAL(10,2);
    
    -- Declarar cursor
    DECLARE cur_empleados CURSOR FOR 
        SELECT id, salario FROM empleados;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur_empleados;
    
    read_loop: LOOP
        FETCH cur_empleados INTO emp_id, emp_salario;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- Actualizar usando una sentencia UPDATE normal
        UPDATE empleados 
        SET salario = emp_salario * 1.1
        WHERE id = emp_id;
    END LOOP;
    
    CLOSE cur_empleados;
END //
DELIMITER ;
```

#### 6.5.4. No son scrollables (no permiten movimientos hacia atrás o saltos)

### 6.6. Ejemplos Prácticos

- Uso de cursores en procedimientos almacenados.  
- Iteración sobre filas para procesar cálculos o insertar datos.

### 6.7. Limitaciones de los Cursores

- Impacto en el rendimiento.  
- Restricciones en MySQL (por ejemplo, no se pueden usar fuera de procedimientos).

### 6.8. Buenas Prácticas con Cursores

- Minimizar su uso en tablas grandes.  
- Alternativas a los cursores (consultas SQL optimizadas).

## 7. Documentación
